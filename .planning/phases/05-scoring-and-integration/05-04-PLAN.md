---
phase: 05-scoring-and-integration
plan: 04
type: execute
wave: 3
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - frontend/src/components/dynamic/__tests__/ScoreDisplay.spec.js
  - frontend/src/components/dynamic/__tests__/DynamicForm.scoring.spec.js
  - frontend/src/composables/__tests__/useSchemaScoring.spec.js
  - frontend/src/utils/__tests__/evidenceDataMigration.spec.js
  - frontend/src/components/forms/__tests__/SchemaDrivenPrecurationForm.spec.js
autonomous: true

must_haves:
  truths:
    - "ScoreDisplay component tests verify rendering for all scoring engines"
    - "useSchemaScoring composable tests cover edge cases"
    - "Evidence data migration tests verify legacy format handling"
    - "All new tests pass with lint clean"
  artifacts:
    - path: "frontend/src/components/dynamic/__tests__/ScoreDisplay.spec.js"
      provides: "ScoreDisplay component tests"
      min_lines: 100
    - path: "frontend/src/composables/__tests__/useSchemaScoring.spec.js"
      provides: "useSchemaScoring composable tests"
      min_lines: 80
    - path: "frontend/src/utils/__tests__/evidenceDataMigration.spec.js"
      provides: "Migration utility tests"
      min_lines: 60
  key_links:
    - from: "frontend/src/components/dynamic/__tests__/ScoreDisplay.spec.js"
      to: "ScoreDisplay.vue"
      via: "component import"
      pattern: "import ScoreDisplay"
---

<objective>
Add comprehensive test coverage for Phase 5 scoring and integration features

Purpose: Ensure ScoreDisplay, useSchemaScoring, evidence migration, and integration work correctly
Output: Test files covering scoring display, composable logic, and data migration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-scoring-and-integration/05-01-SUMMARY.md
@.planning/phases/05-scoring-and-integration/05-02-SUMMARY.md
@.planning/phases/05-scoring-and-integration/05-03-SUMMARY.md

# Test patterns from Phase 4
@frontend/src/components/dynamic/__tests__/DynamicForm.validation.spec.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add useSchemaScoring composable tests</name>
  <files>frontend/src/composables/__tests__/useSchemaScoring.spec.js</files>
  <action>
Create test file for useSchemaScoring composable:

```javascript
import { describe, it, expect } from 'vitest'
import { ref, nextTick } from 'vue'
import { useSchemaScoring } from '../useSchemaScoring'

describe('useSchemaScoring', () => {
  // Test data for different scoring engines
  const clingenScores = {
    genetic_evidence_score: 8,
    experimental_evidence_score: 4,
    total_score: 12
  }

  const clingenConfig = {
    engine: 'clingen',
    max_score: 18,
    classification_thresholds: {
      Definitive: 12,
      Strong: 7,
      Moderate: 2,
      Limited: 0.1
    }
  }

  const genccScores = {
    supporting_score: 3,
    moderate_score: 2,
    total_score: 5
  }

  const genccConfig = {
    engine: 'gencc',
    max_score: 8,
    classification_thresholds: {
      Definitive: 7,
      Strong: 5,
      Moderate: 3,
      Limited: 1
    }
  }

  describe('totalScore calculation', () => {
    it('returns 0 when scoreCalculations is null', () => {
      const scores = ref(null)
      const config = ref(clingenConfig)
      const { totalScore } = useSchemaScoring(scores, config)
      expect(totalScore.value).toBe(0)
    })

    it('sums score_calculations values correctly', () => {
      const scores = ref(clingenScores)
      const config = ref(clingenConfig)
      const { totalScore } = useSchemaScoring(scores, config)
      expect(totalScore.value).toBe(12)
    })

    it('uses total_score if present', () => {
      const scores = ref({ ...clingenScores, total_score: 15 })
      const config = ref(clingenConfig)
      const { totalScore } = useSchemaScoring(scores, config)
      expect(totalScore.value).toBe(15)
    })
  })

  describe('classification derivation', () => {
    it('returns Definitive for score >= 12 (ClinGen)', () => {
      const scores = ref({ total_score: 12 })
      const config = ref(clingenConfig)
      const { classification } = useSchemaScoring(scores, config)
      expect(classification.value).toBe('Definitive')
    })

    it('returns Strong for score >= 7 and < 12', () => {
      const scores = ref({ total_score: 8 })
      const config = ref(clingenConfig)
      const { classification } = useSchemaScoring(scores, config)
      expect(classification.value).toBe('Strong')
    })

    it('returns Moderate for score >= 2 and < 7', () => {
      const scores = ref({ total_score: 4 })
      const config = ref(clingenConfig)
      const { classification } = useSchemaScoring(scores, config)
      expect(classification.value).toBe('Moderate')
    })

    it('returns Limited for score >= 0.1 and < 2', () => {
      const scores = ref({ total_score: 1 })
      const config = ref(clingenConfig)
      const { classification } = useSchemaScoring(scores, config)
      expect(classification.value).toBe('Limited')
    })

    it('returns No Known Relationship for score < 0.1', () => {
      const scores = ref({ total_score: 0 })
      const config = ref(clingenConfig)
      const { classification } = useSchemaScoring(scores, config)
      expect(classification.value).toBe('No Known Disease Relationship')
    })

    it('works with GenCC thresholds', () => {
      const scores = ref({ total_score: 5 })
      const config = ref(genccConfig)
      const { classification } = useSchemaScoring(scores, config)
      expect(classification.value).toBe('Strong')
    })
  })

  describe('classificationColor', () => {
    it('returns success for Definitive', () => {
      const scores = ref({ total_score: 15 })
      const config = ref(clingenConfig)
      const { classificationColor } = useSchemaScoring(scores, config)
      expect(classificationColor.value).toBe('success')
    })

    it('returns success for Strong', () => {
      const scores = ref({ total_score: 8 })
      const config = ref(clingenConfig)
      const { classificationColor } = useSchemaScoring(scores, config)
      expect(classificationColor.value).toBe('success')
    })

    it('returns info for Moderate', () => {
      const scores = ref({ total_score: 4 })
      const config = ref(clingenConfig)
      const { classificationColor } = useSchemaScoring(scores, config)
      expect(classificationColor.value).toBe('info')
    })

    it('returns warning for Limited', () => {
      const scores = ref({ total_score: 1 })
      const config = ref(clingenConfig)
      const { classificationColor } = useSchemaScoring(scores, config)
      expect(classificationColor.value).toBe('warning')
    })

    it('returns grey for No Known Relationship', () => {
      const scores = ref({ total_score: 0 })
      const config = ref(clingenConfig)
      const { classificationColor } = useSchemaScoring(scores, config)
      expect(classificationColor.value).toBe('grey')
    })
  })

  describe('nearThreshold detection', () => {
    it('returns true when within 1 point of next threshold', () => {
      const scores = ref({ total_score: 6.5 })  // 0.5 from Strong (7)
      const config = ref(clingenConfig)
      const { nearThreshold } = useSchemaScoring(scores, config)
      expect(nearThreshold.value).toBe(true)
    })

    it('returns false when not near threshold', () => {
      const scores = ref({ total_score: 4 })  // 3 from Strong (7)
      const config = ref(clingenConfig)
      const { nearThreshold } = useSchemaScoring(scores, config)
      expect(nearThreshold.value).toBe(false)
    })
  })

  describe('progressPercentage', () => {
    it('calculates percentage correctly', () => {
      const scores = ref({ total_score: 9 })
      const config = ref(clingenConfig)  // max_score: 18
      const { progressPercentage } = useSchemaScoring(scores, config)
      expect(progressPercentage.value).toBe(50)
    })

    it('caps at 100%', () => {
      const scores = ref({ total_score: 20 })
      const config = ref(clingenConfig)
      const { progressPercentage } = useSchemaScoring(scores, config)
      expect(progressPercentage.value).toBe(100)
    })
  })

  describe('reactivity', () => {
    it('updates when scores change', async () => {
      const scores = ref({ total_score: 5 })
      const config = ref(clingenConfig)
      const { classification } = useSchemaScoring(scores, config)
      expect(classification.value).toBe('Moderate')

      scores.value = { total_score: 12 }
      await nextTick()
      expect(classification.value).toBe('Definitive')
    })
  })
})
```
  </action>
  <verify>Run `cd frontend && npm test -- useSchemaScoring.spec.js` passes all tests.</verify>
  <done>useSchemaScoring composable has comprehensive test coverage for all scoring engines</done>
</task>

<task type="auto">
  <name>Task 2: Add evidence data migration tests</name>
  <files>frontend/src/utils/__tests__/evidenceDataMigration.spec.js</files>
  <action>
Create test file for evidence data migration utility:

```javascript
import { describe, it, expect } from 'vitest'
import { migrateLegacyFormat, isLegacyFormat } from '../evidenceDataMigration'

describe('evidenceDataMigration', () => {
  describe('isLegacyFormat', () => {
    it('returns false for null/undefined', () => {
      expect(isLegacyFormat(null)).toBe(false)
      expect(isLegacyFormat(undefined)).toBe(false)
    })

    it('returns false for empty object', () => {
      expect(isLegacyFormat({})).toBe(false)
    })

    it('returns false for already migrated data', () => {
      expect(isLegacyFormat({ _version: '2.0', disease_name: 'Test' })).toBe(false)
    })

    it('returns true for data with evidence_items', () => {
      expect(isLegacyFormat({ evidence_items: [] })).toBe(true)
    })

    it('returns true for data with disease_entity', () => {
      expect(isLegacyFormat({ disease_entity: { name: 'Test' } })).toBe(true)
    })
  })

  describe('migrateLegacyFormat', () => {
    it('returns unchanged if already migrated', () => {
      const data = { _version: '2.0', disease_name: 'Test Disease' }
      const result = migrateLegacyFormat(data)
      expect(result).toEqual(data)
    })

    it('returns unchanged with version for non-legacy format', () => {
      const data = { disease_name: 'Test', mode_of_inheritance: 'AD' }
      const result = migrateLegacyFormat(data)
      expect(result._version).toBe('2.0')
      expect(result.disease_name).toBe('Test')
    })

    it('migrates disease_entity to flat fields', () => {
      const legacy = {
        disease_entity: {
          name: 'SCN1A-related seizure disorder',
          mondo_id: 'MONDO:0000001',
          inheritance: 'Autosomal Dominant'
        }
      }
      const result = migrateLegacyFormat(legacy)
      expect(result._version).toBe('2.0')
      expect(result.disease_name).toBe('SCN1A-related seizure disorder')
      expect(result.mondo_id).toBe('MONDO:0000001')
      expect(result.mode_of_inheritance).toBe('Autosomal Dominant')
    })

    it('preserves genetic_evidence structure', () => {
      const legacy = {
        genetic_evidence: {
          case_level_score: 5,
          segregation_score: 2
        }
      }
      const result = migrateLegacyFormat(legacy)
      expect(result.genetic_evidence).toEqual(legacy.genetic_evidence)
    })

    it('preserves experimental_evidence structure', () => {
      const legacy = {
        experimental_evidence: {
          functional_score: 2,
          model_system_score: 1
        }
      }
      const result = migrateLegacyFormat(legacy)
      expect(result.experimental_evidence).toEqual(legacy.experimental_evidence)
    })

    it('handles null/undefined gracefully', () => {
      expect(migrateLegacyFormat(null)).toBe(null)
      expect(migrateLegacyFormat(undefined)).toBe(undefined)
    })

    it('handles empty object', () => {
      const result = migrateLegacyFormat({})
      expect(result).toEqual({})
    })

    it('preserves top-level fields not in disease_entity', () => {
      const legacy = {
        disease_entity: { name: 'Test' },
        curator_notes: 'Some notes',
        pmids: ['12345', '67890']
      }
      const result = migrateLegacyFormat(legacy)
      expect(result.curator_notes).toBe('Some notes')
      expect(result.pmids).toEqual(['12345', '67890'])
    })

    it('prefers disease_entity values over top-level when both exist', () => {
      const legacy = {
        disease_name: 'Old name',
        disease_entity: { name: 'New name from entity' }
      }
      const result = migrateLegacyFormat(legacy)
      expect(result.disease_name).toBe('New name from entity')
    })

    it('falls back to top-level disease_name when disease_entity.name is empty', () => {
      const legacy = {
        disease_name: 'Fallback name',
        disease_entity: { name: '' }
      }
      const result = migrateLegacyFormat(legacy)
      expect(result.disease_name).toBe('Fallback name')
    })
  })
})
```
  </action>
  <verify>Run `cd frontend && npm test -- evidenceDataMigration.spec.js` passes all tests.</verify>
  <done>Evidence data migration utility has comprehensive test coverage for legacy format handling</done>
</task>

<task type="auto">
  <name>Task 3: Add ScoreDisplay component tests</name>
  <files>frontend/src/components/dynamic/__tests__/ScoreDisplay.spec.js</files>
  <action>
Create test file for ScoreDisplay component following patterns from DynamicForm.validation.spec.js:

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { ref } from 'vue'
import ScoreDisplay from '../ScoreDisplay.vue'

// Mock useSchemaScoring composable
vi.mock('@/composables/useSchemaScoring', () => ({
  useSchemaScoring: vi.fn((scores, config) => ({
    totalScore: ref(scores.value?.total_score || 0),
    categoryScores: ref(scores.value || {}),
    classification: ref('Moderate'),
    classificationColor: ref('info'),
    nearThreshold: ref(false),
    progressPercentage: ref(50),
    maxScore: ref(config.value?.max_score || 18)
  }))
}))

// Mock useLogger
vi.mock('@/composables/useLogger', () => ({
  useLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

// Vuetify component stubs
const vuetifyStubs = {
  'v-card': {
    template: '<div class="v-card"><slot /></div>'
  },
  'v-card-title': {
    template: '<div class="v-card-title"><slot /></div>'
  },
  'v-card-text': {
    template: '<div class="v-card-text"><slot /></div>'
  },
  'v-icon': {
    template: '<span class="v-icon"><slot /></span>',
    props: ['icon', 'start', 'color', 'size']
  },
  'v-chip': {
    template: '<span class="v-chip" :data-color="color"><slot /></span>',
    props: ['color', 'size', 'variant']
  },
  'v-skeleton-loader': {
    template: '<div class="v-skeleton-loader" />',
    props: ['type']
  },
  'v-progress-linear': {
    template: '<div class="v-progress-linear" :data-value="modelValue"><slot /></div>',
    props: ['modelValue', 'color', 'height', 'rounded']
  },
  'v-expansion-panels': {
    template: '<div class="v-expansion-panels"><slot /></div>'
  },
  'v-expansion-panel': {
    template: '<div class="v-expansion-panel"><slot /></div>'
  },
  'v-expansion-panel-title': {
    template: '<div class="v-expansion-panel-title"><slot /></div>'
  },
  'v-expansion-panel-text': {
    template: '<div class="v-expansion-panel-text"><slot /></div>'
  },
  'v-row': {
    template: '<div class="v-row"><slot /></div>'
  },
  'v-col': {
    template: '<div class="v-col"><slot /></div>',
    props: ['cols']
  }
}

describe('ScoreDisplay', () => {
  const defaultProps = {
    scoreCalculations: {
      genetic_evidence_score: 6,
      experimental_evidence_score: 3,
      total_score: 9
    },
    scoringConfiguration: {
      engine: 'clingen',
      max_score: 18,
      classification_thresholds: {
        Definitive: 12,
        Strong: 7,
        Moderate: 2,
        Limited: 0.1
      }
    },
    loading: false
  }

  function createWrapper(props = {}) {
    return mount(ScoreDisplay, {
      props: { ...defaultProps, ...props },
      global: {
        stubs: vuetifyStubs
      }
    })
  }

  describe('loading state', () => {
    it('shows skeleton loader when loading', () => {
      const wrapper = createWrapper({ loading: true })
      expect(wrapper.find('.v-skeleton-loader').exists()).toBe(true)
    })

    it('hides skeleton loader when not loading', () => {
      const wrapper = createWrapper({ loading: false })
      expect(wrapper.find('.v-skeleton-loader').exists()).toBe(false)
    })
  })

  describe('score display', () => {
    it('renders card with Live Scoring title', () => {
      const wrapper = createWrapper()
      expect(wrapper.find('.v-card-title').text()).toContain('Live Scoring')
    })

    it('displays classification chip', () => {
      const wrapper = createWrapper()
      const chip = wrapper.find('.v-chip')
      expect(chip.exists()).toBe(true)
    })

    it('shows progress bar', () => {
      const wrapper = createWrapper()
      expect(wrapper.find('.v-progress-linear').exists()).toBe(true)
    })
  })

  describe('classification colors', () => {
    it('uses info color for Moderate classification', () => {
      const wrapper = createWrapper()
      const chip = wrapper.find('.v-chip')
      expect(chip.attributes('data-color')).toBe('info')
    })
  })

  describe('threshold panel', () => {
    it('renders expansion panel for thresholds', () => {
      const wrapper = createWrapper()
      expect(wrapper.find('.v-expansion-panels').exists()).toBe(true)
    })
  })

  describe('null handling', () => {
    it('handles null scoreCalculations gracefully', () => {
      const wrapper = createWrapper({ scoreCalculations: null })
      expect(wrapper.exists()).toBe(true)
    })

    it('handles null scoringConfiguration gracefully', () => {
      const wrapper = createWrapper({ scoringConfiguration: null })
      expect(wrapper.exists()).toBe(true)
    })
  })
})
```
  </action>
  <verify>Run `cd frontend && npm test -- ScoreDisplay.spec.js` passes all tests.</verify>
  <done>ScoreDisplay component has test coverage for rendering, loading states, and edge cases</done>
</task>

</tasks>

<verification>
1. Run `cd frontend && npm test` - all new tests should pass
2. Run `cd frontend && npm run lint` - should pass
3. Check test coverage: `cd frontend && npm run coverage` - new files should have >80% coverage
</verification>

<success_criteria>
- useSchemaScoring composable tests cover all scoring engines and edge cases
- Evidence data migration tests verify legacy format handling
- ScoreDisplay component tests verify rendering and states
- All tests pass with lint clean
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-scoring-and-integration/05-04-SUMMARY.md`
</output>
