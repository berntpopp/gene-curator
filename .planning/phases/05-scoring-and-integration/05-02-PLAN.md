---
phase: 05-scoring-and-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/components/forms/SchemaDrivenCurationForm.vue
  - frontend/src/components/dynamic/DynamicForm.vue
  - backend/app/models/models.py
  - database/sql/migrations/add_use_dynamic_form_flag.sql
autonomous: true

must_haves:
  truths:
    - "ClinGen schemas render using DynamicForm when use_dynamic_form flag is true"
    - "Existing ClinGen curations load and save correctly through DynamicForm"
    - "Evidence data auto-migrates legacy format on load"
    - "Form recovery works with DynamicForm for ClinGen schemas"
  artifacts:
    - path: "frontend/src/components/forms/SchemaDrivenCurationForm.vue"
      provides: "Bypass removed, uses feature flag"
      contains: "use_dynamic_form"
    - path: "database/sql/migrations/add_use_dynamic_form_flag.sql"
      provides: "Database migration for feature flag"
      contains: "use_dynamic_form"
  key_links:
    - from: "frontend/src/components/forms/SchemaDrivenCurationForm.vue"
      to: "DynamicForm.vue"
      via: "conditional rendering based on flag"
      pattern: "useDynamicForm"
    - from: "frontend/src/components/forms/SchemaDrivenCurationForm.vue"
      to: "migrateLegacyFormat"
      via: "function call on curation load"
      pattern: "migrateLegacyFormat"
---

<objective>
Remove ClinGen bypass from SchemaDrivenCurationForm using feature flag transition

Purpose: Enable ClinGen schemas to use DynamicForm while maintaining backward compatibility
Output: SchemaDrivenCurationForm uses feature flag to determine form component, evidence data auto-migrates
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-scoring-and-integration/05-CONTEXT.md
@.planning/phases/05-scoring-and-integration/05-RESEARCH.md
@.planning/phases/05-scoring-and-integration/05-01-SUMMARY.md

# Key existing files
@frontend/src/components/forms/SchemaDrivenCurationForm.vue
@frontend/src/components/dynamic/DynamicForm.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add use_dynamic_form flag to schema model</name>
  <files>
    backend/app/models/models.py
    database/sql/migrations/add_use_dynamic_form_flag.sql
  </files>
  <action>
1. Update CurationSchema model in backend/app/models/models.py:
   - Add `use_dynamic_form = Column(Boolean, default=False, nullable=False)` field
   - Add to __repr__ if desired

2. Create migration file database/sql/migrations/add_use_dynamic_form_flag.sql:
```sql
-- Migration: Add use_dynamic_form flag to curation_schemas
-- Purpose: Feature flag for gradual DynamicForm rollout
-- Date: 2026-01-23

-- Add column with default false (safe default)
ALTER TABLE curation_schemas
ADD COLUMN IF NOT EXISTS use_dynamic_form BOOLEAN NOT NULL DEFAULT false;

-- Enable for non-ClinGen schemas immediately (they already use DynamicForm)
UPDATE curation_schemas
SET use_dynamic_form = true
WHERE name NOT ILIKE '%clingen%' AND name NOT ILIKE '%sop%';

-- Optionally enable for one test ClinGen schema for validation
-- UPDATE curation_schemas SET use_dynamic_form = true WHERE name = 'Test ClinGen Schema';

COMMENT ON COLUMN curation_schemas.use_dynamic_form IS
  'When true, use DynamicForm instead of ClinGenCurationForm for this schema';
```

3. Add use_dynamic_form to Pydantic schemas in backend/app/schemas/schemas.py (CurationSchemaRead, CurationSchemaCreate, CurationSchemaUpdate)
  </action>
  <verify>Run `cd backend && uv run python -c "from app.models.models import CurationSchema; print(CurationSchema.__table__.columns.keys())"` shows use_dynamic_form. Migration SQL is valid.</verify>
  <done>use_dynamic_form boolean column exists in CurationSchema model with migration file</done>
</task>

<task type="auto">
  <name>Task 2: Add evidence data migration utility</name>
  <files>frontend/src/utils/evidenceDataMigration.js</files>
  <action>
Create utility for migrating legacy ClinGen evidence_data format to DynamicForm format:

```javascript
/**
 * Migrate legacy ClinGen evidence_data format to DynamicForm format
 *
 * Legacy format (from ClinGenCurationForm):
 * - evidence_items: Array of evidence item objects
 * - Nested structures specific to ClinGen tabs
 *
 * DynamicForm format:
 * - Flat field structure matching schema field_definitions
 * - _version field to mark migrated data
 */

export function migrateLegacyFormat(evidenceData, schemaName) {
  // Return unchanged if already migrated
  if (evidenceData?._version === '2.0') {
    return evidenceData
  }

  // Return unchanged if no data
  if (!evidenceData || Object.keys(evidenceData).length === 0) {
    return evidenceData
  }

  // Check if this looks like ClinGen legacy format
  const isLegacyFormat =
    evidenceData.evidence_items !== undefined ||
    evidenceData.disease_entity !== undefined ||
    evidenceData.genetic_evidence !== undefined

  if (!isLegacyFormat) {
    return { ...evidenceData, _version: '2.0' }
  }

  // Migrate ClinGen legacy format
  const migrated = {
    _version: '2.0',

    // Disease entity fields
    disease_name: evidenceData.disease_entity?.name || evidenceData.disease_name || '',
    mondo_id: evidenceData.disease_entity?.mondo_id || evidenceData.mondo_id || '',
    mode_of_inheritance: evidenceData.disease_entity?.inheritance || evidenceData.mode_of_inheritance || '',

    // Preserve genetic_evidence and experimental_evidence structures
    genetic_evidence: evidenceData.genetic_evidence || {},
    experimental_evidence: evidenceData.experimental_evidence || {},

    // Preserve other top-level fields
    ...Object.fromEntries(
      Object.entries(evidenceData).filter(([key]) =>
        !['disease_entity', '_version'].includes(key)
      )
    )
  }

  return migrated
}

export function isLegacyFormat(evidenceData) {
  return evidenceData && !evidenceData._version && (
    evidenceData.evidence_items !== undefined ||
    evidenceData.disease_entity !== undefined
  )
}
```

This handles the common migration cases. Edge cases with malformed data will fall through gracefully.
  </action>
  <verify>Run `cd frontend && npm run build` passes. Unit test the function with sample legacy data.</verify>
  <done>migrateLegacyFormat function handles ClinGen legacy evidence_data format conversion</done>
</task>

<task type="auto">
  <name>Task 3: Update SchemaDrivenCurationForm to use feature flag</name>
  <files>frontend/src/components/forms/SchemaDrivenCurationForm.vue</files>
  <action>
Modify SchemaDrivenCurationForm.vue to use feature flag instead of name-based ClinGen detection:

1. Import migration utility:
```javascript
import { migrateLegacyFormat, isLegacyFormat } from '@/utils/evidenceDataMigration'
```

2. Replace isClinGenSchema computed with useDynamicForm:
```javascript
// REMOVE this:
// const isClinGenSchema = computed(() => {
//   const schemaName = schema.value?.name?.toLowerCase() || ''
//   return schemaName.includes('clingen') || schemaName.includes('sop')
// })

// ADD this:
const useDynamicForm = computed(() => {
  // Feature flag takes precedence
  if (schema.value?.use_dynamic_form !== undefined) {
    return schema.value.use_dynamic_form
  }
  // Fallback: non-ClinGen schemas always use DynamicForm
  const schemaName = schema.value?.name?.toLowerCase() || ''
  return !schemaName.includes('clingen') && !schemaName.includes('sop')
})
```

3. Update template conditional:
```vue
<!-- CHANGE FROM: v-if="isClinGenSchema && !loadingSchema" -->
<!-- CHANGE TO: -->
<ClinGenCurationForm
  v-if="!useDynamicForm && !loadingSchema"
  ...
/>

<!-- Generic form now uses DynamicForm for all schemas where useDynamicForm is true -->
<v-form v-else ...>
```

4. Add migration on curation load in loadCuration function:
```javascript
async function loadCuration() {
  // ... existing code ...
  if (curation) {
    // Auto-migrate legacy format if needed
    if (isLegacyFormat(curation.evidence_data)) {
      logger.info('Migrating legacy evidence_data format', { curationId: props.curationId })
      evidenceData.value = migrateLegacyFormat(curation.evidence_data, schema.value?.name)
    } else {
      evidenceData.value = curation.evidence_data || {}
    }
    // ... rest of existing code ...
  }
}
```

5. Update form recovery key to include schema version:
```javascript
const recoveryKey = computed(() =>
  `curation-${props.curationId || 'new'}-schema-${props.schemaId}-v2`
)
```

The v2 suffix prevents old recovery data from conflicting with migrated format.
  </action>
  <verify>Run `cd frontend && npm run lint` passes. Run `cd frontend && npm run build` passes.</verify>
  <done>SchemaDrivenCurationForm uses use_dynamic_form flag and auto-migrates legacy evidence data</done>
</task>

</tasks>

<verification>
1. Run `cd frontend && npm run build` - should pass
2. Run `cd frontend && npm run lint` - should pass
3. Run `cd backend && uv run pytest tests/` - should pass
4. Apply migration: `psql -f database/sql/migrations/add_use_dynamic_form_flag.sql`
5. Set flag: `UPDATE curation_schemas SET use_dynamic_form = true WHERE id = 'test-schema-id'`
6. Load existing ClinGen curation - verify data migrates and displays correctly
</verification>

<success_criteria>
- use_dynamic_form column exists in curation_schemas table
- SchemaDrivenCurationForm respects use_dynamic_form flag
- Legacy evidence_data auto-migrates on load
- Form recovery works with migrated data format
- Existing ClinGen curations load and save correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-scoring-and-integration/05-02-SUMMARY.md`
</output>
