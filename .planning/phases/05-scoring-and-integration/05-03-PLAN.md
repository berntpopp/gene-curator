---
phase: 05-scoring-and-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/views/curation/PrecurationFormView.vue
  - frontend/src/components/forms/SchemaDrivenPrecurationForm.vue
autonomous: true

must_haves:
  truths:
    - "PrecurationFormView renders fields from schema field_definitions"
    - "Existing precurations load and save correctly through DynamicForm"
    - "Form retains gene context header and workflow navigation"
    - "Form recovery works with DynamicForm for precurations"
  artifacts:
    - path: "frontend/src/components/forms/SchemaDrivenPrecurationForm.vue"
      provides: "Schema-driven precuration form component"
      min_lines: 200
    - path: "frontend/src/views/curation/PrecurationFormView.vue"
      provides: "Updated view using SchemaDrivenPrecurationForm"
      contains: "SchemaDrivenPrecurationForm"
  key_links:
    - from: "frontend/src/views/curation/PrecurationFormView.vue"
      to: "SchemaDrivenPrecurationForm.vue"
      via: "component import and rendering"
      pattern: "import SchemaDrivenPrecurationForm"
    - from: "frontend/src/components/forms/SchemaDrivenPrecurationForm.vue"
      to: "DynamicForm.vue"
      via: "component delegation"
      pattern: "import DynamicForm"
---

<objective>
Migrate PrecurationFormView to use DynamicForm-based rendering

Purpose: Enable precuration forms to render from schema field_definitions instead of hardcoded panels
Output: SchemaDrivenPrecurationForm component, updated PrecurationFormView
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-scoring-and-integration/05-CONTEXT.md
@.planning/phases/05-scoring-and-integration/05-RESEARCH.md
@.planning/phases/05-scoring-and-integration/05-01-SUMMARY.md

# Key existing files
@frontend/src/views/curation/PrecurationFormView.vue
@frontend/src/components/forms/SchemaDrivenCurationForm.vue
@frontend/src/components/dynamic/DynamicForm.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SchemaDrivenPrecurationForm component</name>
  <files>frontend/src/components/forms/SchemaDrivenPrecurationForm.vue</files>
  <action>
Create SchemaDrivenPrecurationForm.vue following the pattern of SchemaDrivenCurationForm:

**Props:**
- schemaId: String (required) - precuration schema ID
- precurationId: String (optional) - for editing existing precuration
- scopeId: String (required)
- geneId: String (optional)
- gene: Object (optional) - gene details for display
- readonly: Boolean (default false)

**Key structure:**
```vue
<template>
  <ErrorBoundary @error="handleFormError">
    <v-form ref="formRef" @submit.prevent="handleSubmit" @keydown="handleKeydown">
      <v-card>
        <!-- Header with precuration context -->
        <v-card-title class="d-flex align-center">
          <span>{{ gene?.symbol }} - Precuration</span>
          <v-chip v-if="isDraft" color="warning" size="small" class="ml-2">Draft</v-chip>
          <v-spacer />
          <v-chip v-if="lastSaved" color="success" size="small" variant="outlined">
            <v-icon start size="small">mdi-content-save</v-icon>
            Saved {{ formatRelativeTime(lastSaved) }}
          </v-chip>
        </v-card-title>

        <v-divider />

        <v-card-text>
          <v-skeleton-loader v-if="loadingSchema" type="article" />

          <DynamicForm
            v-else-if="schemaId"
            :schema-id="schemaId"
            :initial-data="evidenceData"
            :title="schema?.name || 'Precuration Form'"
            :readonly="readonly"
            @update:model-value="handleEvidenceChange"
            @validation-change="handleValidationChange"
            @submit="handleSubmit"
            @save-draft="handleSaveDraft"
          />

          <v-alert v-else type="warning" variant="tonal">
            No schema assigned. Please contact an administrator.
          </v-alert>
        </v-card-text>

        <v-divider />

        <FormActions
          :can-undo="canUndo"
          :can-redo="canRedo"
          :can-submit="canSubmit"
          :saving="savingDraft"
          :submitting="submitting"
          @undo="undo"
          @redo="redo"
          @save-draft="handleSaveDraft"
          @submit="handleSubmit"
          @cancel="handleCancel"
        />
      </v-card>
    </v-form>

    <FormRecoveryDialog
      v-model="showRecoveryDialog"
      :recovery-data="recoveryData"
      @restore="restoreRecovery"
      @discard="discardRecovery"
    />
  </ErrorBoundary>
</template>
```

**Key functionality (adapt from SchemaDrivenCurationForm):**
- Use precurationsStore instead of curationsStore for CRUD operations
- Form recovery with key: `precuration-${precurationId || 'new'}-schema-${schemaId}`
- Undo/redo via useHistory composable
- Keyboard shortcuts (Ctrl+S, Ctrl+Z, Ctrl+Enter, Esc)
- Load schema via schemasStore.fetchSchemaById and validationStore.generateJsonSchema
- Handle submit: precurationsStore.submitPrecuration()
- Handle save draft: precurationsStore.saveDraft()

Do NOT include scoring sidebar (precurations typically don't have scoring). Only include if schema has scoring_configuration.
  </action>
  <verify>Run `cd frontend && npm run build` passes. Component renders without errors.</verify>
  <done>SchemaDrivenPrecurationForm component delegates to DynamicForm with precuration-specific CRUD operations</done>
</task>

<task type="auto">
  <name>Task 2: Update PrecurationFormView to use SchemaDrivenPrecurationForm</name>
  <files>frontend/src/views/curation/PrecurationFormView.vue</files>
  <action>
Refactor PrecurationFormView.vue to use SchemaDrivenPrecurationForm:

1. Import new component:
```javascript
import SchemaDrivenPrecurationForm from '@/components/forms/SchemaDrivenPrecurationForm.vue'
```

2. Remove all hardcoded form panels (disease, lumping, literature, etc.) from template

3. Keep the gene context header (the prominent blue v-card with gene symbol, HGNC/NCBI links) - this provides valuable context

4. Replace form content with SchemaDrivenPrecurationForm:
```vue
<!-- Gene Context Header (KEEP) -->
<v-card class="mb-6 bg-primary" variant="flat">
  <!-- ... existing header content ... -->
</v-card>

<!-- Replace hardcoded form with schema-driven form -->
<SchemaDrivenPrecurationForm
  :schema-id="precurationSchemaId"
  :precuration-id="precurationId"
  :scope-id="scopeId"
  :gene-id="geneId"
  :gene="gene"
  :readonly="readonly"
  @submit="handleFormSubmit"
  @cancel="handleCancel"
  @saved="handleSaved"
/>
```

5. Simplify script section:
- Keep: Route params extraction (scopeId, geneId, precurationId)
- Keep: Gene loading logic (loadGene function)
- Keep: Scope loading logic
- Remove: All hardcoded form state (form ref with disease_name, mode_of_inheritance, etc.)
- Remove: Expansion panel state
- Remove: Hardcoded validation rules
- Remove: Helper functions for hardcoded fields (getCurationTypeLabel, etc.)

6. Keep navigation handlers:
- handleCancel: router.back() or navigate to scope detail
- handleFormSubmit: navigate to workflow or confirmation
- handleSaved: show success toast

The view becomes a thin wrapper that:
- Extracts route params
- Loads gene data
- Resolves precuration schema ID from scope
- Renders SchemaDrivenPrecurationForm

This reduces PrecurationFormView from ~800 lines to ~200 lines.
  </action>
  <verify>Run `cd frontend && npm run lint` passes. Run `cd frontend && npm run build` passes.</verify>
  <done>PrecurationFormView renders schema-driven form while preserving gene context header</done>
</task>

<task type="auto">
  <name>Task 3: Wire form recovery and data persistence</name>
  <files>
    frontend/src/components/forms/SchemaDrivenPrecurationForm.vue
    frontend/src/views/curation/PrecurationFormView.vue
  </files>
  <action>
Ensure form recovery and data persistence work correctly:

1. In SchemaDrivenPrecurationForm, verify useFormRecovery integration:
```javascript
const recoveryKey = computed(() =>
  `precuration-${props.precurationId || 'new'}-schema-${props.schemaId}`
)

const {
  showRecoveryDialog,
  recoveryData,
  lastSaved,
  restoreRecovery,
  discardRecovery,
  clearRecovery
} = useFormRecovery(recoveryKey.value, evidenceData, {
  saveInterval: 5000,
  maxAge: 24 * 60 * 60 * 1000
})
```

2. Clear recovery on schema change:
```javascript
watch(
  () => props.schemaId,
  (newId, oldId) => {
    if (oldId && newId !== oldId) {
      clearRecovery()
      evidenceData.value = {}
      logger.info('Schema changed, cleared form recovery', { oldId, newId })
    }
  }
)
```

3. Verify save draft calls precurationsStore.saveDraft() with correct payload:
```javascript
async function handleSaveDraft() {
  savingDraft.value = true
  try {
    const payload = {
      evidence_data: evidenceData.value,
      lock_version: lockVersion.value
    }

    if (props.precurationId) {
      const updated = await precurationsStore.saveDraft(props.precurationId, payload)
      if (updated) {
        lockVersion.value = updated.lock_version
        emit('saved')
      }
    } else {
      // Create new precuration as draft
      const created = await precurationsStore.createPrecuration({
        gene_id: props.geneId,
        scope_id: props.scopeId,
        evidence_data: evidenceData.value
      })
      // Navigate to edit the created precuration
      router.replace({
        name: 'precuration-edit',
        params: { scopeId: props.scopeId, precurationId: created.id }
      })
    }

    notificationsStore.addToast('Draft saved', 'success')
    clearRecovery()
  } catch (error) {
    logger.error('Failed to save draft', { error: error.message })
    notificationsStore.addToast('Failed to save draft', 'error')
  } finally {
    savingDraft.value = false
  }
}
```

4. Load existing precuration data on mount:
```javascript
async function loadPrecuration() {
  if (!props.precurationId) return

  try {
    const precuration = await precurationsStore.fetchPrecurationById(props.precurationId)
    if (precuration) {
      evidenceData.value = precuration.evidence_data || {}
      lockVersion.value = precuration.lock_version || 0
      isDraft.value = precuration.status === 'draft'
    }
  } catch (error) {
    logger.error('Failed to load precuration', { error: error.message })
    notificationsStore.addToast('Failed to load precuration', 'error')
  }
}

onMounted(async () => {
  await loadSchema()
  await loadPrecuration()
})
```
  </action>
  <verify>Test form recovery: start filling form, close tab, reopen - recovery dialog should appear. Save draft and verify data persists.</verify>
  <done>Form recovery and data persistence work correctly with DynamicForm for precurations</done>
</task>

</tasks>

<verification>
1. Run `cd frontend && npm run build` - should pass
2. Run `cd frontend && npm run lint` - should pass
3. Navigate to new precuration form - verify it renders from schema
4. Fill form, close tab, reopen - verify recovery dialog appears
5. Save draft - verify data persists
6. Load existing precuration - verify data displays correctly
</verification>

<success_criteria>
- PrecurationFormView renders fields from schema field_definitions
- Gene context header preserved (symbol, HGNC/NCBI links)
- Form recovery works with DynamicForm
- Draft save/load works correctly
- Existing precurations load and save correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-scoring-and-integration/05-03-SUMMARY.md`
</output>
