---
phase: 01-field-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/dynamic/componentRegistry.js
  - frontend/src/components/dynamic/DynamicField.vue
autonomous: true
user_setup: []

must_haves:
  truths:
    - "DynamicField renders specialized components when field schema specifies component property"
    - "Missing components fall back to editable text field with warning log"
    - "Nested objects render with progressive background tinting at depth 2+"
    - "Recursion stops at MAX_DEPTH=10 with warning alert"
    - "Unknown field types render as editable text field with label suffix"
  artifacts:
    - path: "frontend/src/components/dynamic/componentRegistry.js"
      provides: "Component name to Vue component mapping"
      exports: ["componentRegistry", "getComponent"]
    - path: "frontend/src/components/dynamic/DynamicField.vue"
      provides: "Dynamic field renderer with registry integration"
      min_lines: 450
  key_links:
    - from: "frontend/src/components/dynamic/DynamicField.vue"
      to: "frontend/src/components/dynamic/componentRegistry.js"
      via: "import { componentRegistry } from './componentRegistry'"
      pattern: "componentRegistry\\[.*component\\]"
    - from: "frontend/src/components/dynamic/componentRegistry.js"
      to: "frontend/src/components/evidence/*.vue"
      via: "import statements"
      pattern: "import.*from.*evidence"
---

<objective>
Create component registry and enhance DynamicField to render any field type from schema definitions.

Purpose: Enable schema-driven forms to use specialized components (MONDOAutocomplete, PMIDInput, etc.) when specified in field_definitions, while gracefully handling unknown types and deeply nested structures.

Output: Working componentRegistry.js and enhanced DynamicField.vue with registry integration, depth tracking, and nested styling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-field-rendering/01-CONTEXT.md
@.planning/phases/01-field-rendering/01-RESEARCH.md
@frontend/src/components/dynamic/DynamicField.vue
@frontend/src/components/dynamic/DynamicForm.vue
@frontend/src/components/evidence/MONDOAutocomplete.vue
@frontend/src/components/evidence/PMIDInput.vue
@frontend/src/components/evidence/HPOInheritanceSelect.vue
@frontend/src/components/evidence/OMIMAutocomplete.vue
@frontend/src/components/evidence/HPOInput.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Component Registry</name>
  <files>frontend/src/components/dynamic/componentRegistry.js</files>
  <action>
Create a new file `componentRegistry.js` in the dynamic components directory with:

1. Import all 5 specialized components:
   - MONDOAutocomplete from '@/components/evidence/MONDOAutocomplete.vue'
   - PMIDInput from '@/components/evidence/PMIDInput.vue'
   - HPOInheritanceSelect from '@/components/evidence/HPOInheritanceSelect.vue'
   - OMIMAutocomplete from '@/components/evidence/OMIMAutocomplete.vue'
   - HPOInput from '@/components/evidence/HPOInput.vue'

2. Export `componentRegistry` object mapping exact component names (case-sensitive) to components:
   ```javascript
   export const componentRegistry = {
     MONDOAutocomplete,
     PMIDInput,
     HPOInheritanceSelect,
     OMIMAutocomplete,
     HPOInput
   }
   ```

3. Export `getComponent(name)` helper function that returns component or null if not found.

4. Add JSDoc documenting expected component names and their purposes.
  </action>
  <verify>
    - File exists at frontend/src/components/dynamic/componentRegistry.js
    - `grep -c "export const componentRegistry" frontend/src/components/dynamic/componentRegistry.js` returns 1
    - `grep -c "export function getComponent" frontend/src/components/dynamic/componentRegistry.js` returns 1
  </verify>
  <done>Registry file exports componentRegistry object with 5 components and getComponent helper function</done>
</task>

<task type="auto">
  <name>Task 2: Enhance DynamicField with Registry and Depth</name>
  <files>frontend/src/components/dynamic/DynamicField.vue</files>
  <action>
Update DynamicField.vue with the following enhancements:

1. **Add imports:**
   - Import `componentRegistry` from './componentRegistry'
   - Import `useLogger` from '@/composables/useLogger'
   - Add `const logger = useLogger()` in script setup

2. **Add depth prop and constants:**
   - Add `depth` prop with type Number, default 0
   - Add `const MAX_DEPTH = 10` constant

3. **Add computed for custom component lookup:**
   ```javascript
   const customComponent = computed(() => {
     if (!props.fieldSchema.component) return null

     const comp = componentRegistry[props.fieldSchema.component]

     if (!comp) {
       logger.warn('Component not found in registry', {
         component: props.fieldSchema.component,
         fieldName: props.fieldName,
         availableComponents: Object.keys(componentRegistry)
       })
     }

     return comp
   })
   ```

4. **Add computed for recursion safety:**
   ```javascript
   const canRenderNested = computed(() => props.depth < MAX_DEPTH)
   ```

5. **Add nested styling function:**
   ```javascript
   function getNestedStyle(depth) {
     if (depth < 2) return {}
     const opacity = Math.min(0.02 + (depth - 2) * 0.01, 0.06)
     return {
       backgroundColor: `rgba(var(--v-theme-surface-variant), ${opacity})`,
       transition: 'background-color 0.2s ease'
     }
   }
   ```

6. **Update template:**
   - Add custom component rendering at TOP of template (before other v-if chains):
     ```vue
     <!-- Custom Component from Registry -->
     <component
       v-if="customComponent"
       :is="customComponent"
       :model-value="modelValue"
       v-bind="fieldSchema"
       :required="fieldSchema.required"
       :disabled="disabled"
       @update:model-value="updateValue"
     />
     ```

   - Update object fields section to:
     - Add `v-if` check for `canRenderNested`
     - Pass `:depth="depth + 1"` to recursive DynamicField calls
     - Apply `:style="getNestedStyle(depth)"` to v-card

   - Update array fields section similarly with depth prop and styling

   - Add MAX_DEPTH warning after array/object sections:
     ```vue
     <v-alert v-else-if="!canRenderNested && (fieldSchema.type === 'object' || fieldSchema.type === 'array')"
              type="warning"
              density="compact">
       Maximum nesting depth reached ({{ MAX_DEPTH }} levels)
     </v-alert>
     ```

7. **Fix unknown type fallback:**
   - Change the fallback v-text-field from `readonly` to editable
   - Change label from `getFieldLabel() + ' (Unknown Type)'` to `getFieldLabel() + ' (Unknown Type: ' + fieldSchema.type + ')'`
   - Remove the error-messages prop, add hint instead: `:hint="'Field type not recognized - using text input'"`
   - Add `persistent-hint` prop

8. **Add component-fallback emit:**
   - Add 'component-fallback' to emit array
   - Emit when customComponent lookup fails but component was specified
  </action>
  <verify>
    - `grep -c "componentRegistry" frontend/src/components/dynamic/DynamicField.vue` returns at least 2
    - `grep -c "MAX_DEPTH" frontend/src/components/dynamic/DynamicField.vue` returns at least 2
    - `grep -c "getNestedStyle" frontend/src/components/dynamic/DynamicField.vue` returns at least 2
    - `grep -c "customComponent" frontend/src/components/dynamic/DynamicField.vue` returns at least 2
    - `grep -c "depth:" frontend/src/components/dynamic/DynamicField.vue` returns at least 1 (prop definition)
    - `grep "readonly" frontend/src/components/dynamic/DynamicField.vue` returns nothing (removed from fallback)
    - Run: `cd /home/bernt-popp/development/gene-curator/frontend && npm run lint -- --max-warnings 0` passes
  </verify>
  <done>DynamicField renders custom components from registry, tracks depth, applies nested styling, and uses editable fallback for unknown types</done>
</task>

<task type="auto">
  <name>Task 3: Verify Integration Works</name>
  <files>frontend/src/components/dynamic/DynamicField.vue</files>
  <action>
Verify the implementation works by:

1. Run ESLint to ensure no syntax errors:
   ```bash
   cd frontend && npm run lint
   ```

2. Run existing frontend tests:
   ```bash
   cd frontend && npm run test:unit -- --run
   ```

3. Build the frontend to verify no compilation errors:
   ```bash
   cd frontend && npm run build
   ```

If any of these fail, fix the issues before completing this task.
  </action>
  <verify>
    - `cd /home/bernt-popp/development/gene-curator/frontend && npm run lint -- --max-warnings 0` passes
    - `cd /home/bernt-popp/development/gene-curator/frontend && npm run test:unit -- --run` passes (or shows no regressions)
    - `cd /home/bernt-popp/development/gene-curator/frontend && npm run build` succeeds
  </verify>
  <done>All lint, test, and build checks pass with no regressions</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Component Registry:**
   - File exists at frontend/src/components/dynamic/componentRegistry.js
   - Exports componentRegistry with 5 components
   - Exports getComponent helper

2. **DynamicField Enhancement:**
   - Imports and uses componentRegistry
   - Has depth prop and MAX_DEPTH constant
   - Has customComponent computed with logging
   - Has getNestedStyle function
   - Template renders custom components first
   - Template has depth checks for nested types
   - Unknown type fallback is editable (not readonly)

3. **Quality Checks:**
   - ESLint passes with no warnings
   - Frontend builds successfully
   - Existing tests pass
</verification>

<success_criteria>
- componentRegistry.js exists with 5 components mapped
- DynamicField.vue renders specialized components when fieldSchema.component is set
- Nested objects/arrays get progressive background tinting at depth 2+
- Recursion stops at depth 10 with warning
- Unknown types render as editable text field
- All frontend lint/test/build checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-field-rendering/01-01-SUMMARY.md`
</output>
