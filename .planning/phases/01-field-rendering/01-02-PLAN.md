---
phase: 01-field-rendering
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - frontend/src/components/dynamic/__tests__/DynamicField.spec.js
  - frontend/src/components/dynamic/__tests__/componentRegistry.spec.js
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tests verify componentRegistry returns correct components"
    - "Tests verify DynamicField renders custom components when specified"
    - "Tests verify depth limit prevents infinite recursion"
    - "Tests verify unknown types render as editable text"
    - "All tests pass when run"
  artifacts:
    - path: "frontend/src/components/dynamic/__tests__/componentRegistry.spec.js"
      provides: "Unit tests for component registry"
      min_lines: 30
    - path: "frontend/src/components/dynamic/__tests__/DynamicField.spec.js"
      provides: "Unit tests for DynamicField enhancements"
      min_lines: 80
  key_links:
    - from: "frontend/src/components/dynamic/__tests__/DynamicField.spec.js"
      to: "frontend/src/components/dynamic/DynamicField.vue"
      via: "import and mount"
      pattern: "import.*DynamicField"
    - from: "frontend/src/components/dynamic/__tests__/componentRegistry.spec.js"
      to: "frontend/src/components/dynamic/componentRegistry.js"
      via: "import"
      pattern: "import.*componentRegistry"
---

<objective>
Add test coverage for the component registry and DynamicField enhancements.

Purpose: Ensure the component registry integration, depth tracking, nested styling, and unknown type handling work correctly and prevent regressions.

Output: Test files for componentRegistry and DynamicField with comprehensive coverage of new functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-field-rendering/01-CONTEXT.md
@.planning/phases/01-field-rendering/01-01-SUMMARY.md
@frontend/src/components/dynamic/componentRegistry.js
@frontend/src/components/dynamic/DynamicField.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Component Registry Tests</name>
  <files>frontend/src/components/dynamic/__tests__/componentRegistry.spec.js</files>
  <action>
Create test file for componentRegistry with the following tests:

1. **Setup:**
   - Import componentRegistry and getComponent from '../componentRegistry'
   - Use describe block for 'componentRegistry'

2. **Test cases:**

   a) `it('exports componentRegistry object')` - verify componentRegistry is an object

   b) `it('contains all 5 specialized components')` - verify keys include:
      - MONDOAutocomplete
      - PMIDInput
      - HPOInheritanceSelect
      - OMIMAutocomplete
      - HPOInput

   c) `it('getComponent returns component for valid name')` - test:
      - getComponent('MONDOAutocomplete') returns componentRegistry.MONDOAutocomplete
      - getComponent('PMIDInput') returns componentRegistry.PMIDInput

   d) `it('getComponent returns null for unknown name')` - test:
      - getComponent('UnknownComponent') returns null
      - getComponent('') returns null
      - getComponent(null) returns null

   e) `it('component names are case-sensitive')` - test:
      - getComponent('mondoautocomplete') returns null (wrong case)
      - getComponent('MONDOAUTOCOMPLETE') returns null (wrong case)

Use Vitest's describe, it, expect syntax.
  </action>
  <verify>
    - File exists at frontend/src/components/dynamic/__tests__/componentRegistry.spec.js
    - `grep -c "describe" frontend/src/components/dynamic/__tests__/componentRegistry.spec.js` returns at least 1
    - `grep -c "it(" frontend/src/components/dynamic/__tests__/componentRegistry.spec.js` returns at least 5
    - `cd /home/bernt-popp/development/gene-curator/frontend && npm run test:unit -- --run componentRegistry.spec.js` passes
  </verify>
  <done>componentRegistry.spec.js exists with 5+ test cases covering registry functionality</done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicField Enhancement Tests</name>
  <files>frontend/src/components/dynamic/__tests__/DynamicField.spec.js</files>
  <action>
Create or update test file for DynamicField enhancements. If file exists, add tests. If not, create new file.

1. **Setup with explicit mocking:**
   ```javascript
   import { describe, it, expect, vi, beforeEach } from 'vitest'
   import { mount, shallowMount } from '@vue/test-utils'
   import { createVuetify } from 'vuetify'
   import * as components from 'vuetify/components'
   import * as directives from 'vuetify/directives'
   import DynamicField from '../DynamicField.vue'

   // Mock useLogger composable
   vi.mock('@/composables/useLogger', () => ({
     useLogger: () => ({
       debug: vi.fn(),
       info: vi.fn(),
       warn: vi.fn(),
       error: vi.fn()
     })
   }))

   // Mock componentRegistry - return actual components for valid names, null for invalid
   vi.mock('../componentRegistry', () => ({
     componentRegistry: {
       MONDOAutocomplete: { name: 'MONDOAutocomplete', template: '<div class="mock-mondo"></div>' },
       PMIDInput: { name: 'PMIDInput', template: '<div class="mock-pmid"></div>' },
       HPOInheritanceSelect: { name: 'HPOInheritanceSelect', template: '<div class="mock-hpo-inheritance"></div>' },
       OMIMAutocomplete: { name: 'OMIMAutocomplete', template: '<div class="mock-omim"></div>' },
       HPOInput: { name: 'HPOInput', template: '<div class="mock-hpo"></div>' }
     }
   }))

   const vuetify = createVuetify({ components, directives })

   function mountComponent(props = {}, options = {}) {
     return mount(DynamicField, {
       props: {
         fieldName: 'testField',
         fieldSchema: { type: 'string', title: 'Test Field' },
         modelValue: '',
         ...props
       },
       global: {
         plugins: [vuetify],
         stubs: {
           // Stub recursive DynamicField calls
           DynamicField: true
         },
         ...options.global
       },
       ...options
     })
   }
   ```

2. **Test suite: 'DynamicField'**

   a) **describe('depth tracking')**
      - `it('accepts depth prop with default 0')` - mount without depth prop, verify default
      - `it('passes incremented depth to nested fields')` - mount with object schema, verify child gets depth+1
      - `it('stops rendering at MAX_DEPTH')` - mount with depth=10, object schema, verify warning shown

   b) **describe('custom component rendering')**
      - `it('renders custom component when schema has component property')` - mount with fieldSchema.component='MONDOAutocomplete', verify component renders
      - `it('falls back to text field when component not in registry')` - mount with fieldSchema.component='UnknownComponent', verify text field renders
      - `it('logs warning for missing component')` - verify logger.warn called with component name
      - `it('emits component-fallback event for missing component')` - verify emit called with correct payload

   c) **describe('unknown type fallback')**
      - `it('renders editable text field for unknown types')` - mount with fieldSchema.type='custom_type', verify v-text-field rendered
      - `it('shows type in label for unknown types')` - verify label contains "(Unknown Type:"
      - `it('allows editing unknown type fields')` - verify field is NOT readonly

   d) **describe('nested styling')**
      - `it('applies no background at depth 0-1')` - verify no backgroundColor style
      - `it('applies background tint at depth 2+')` - verify backgroundColor applied
      - `it('increases opacity with depth')` - verify deeper nesting has higher opacity

Use shallow mounting where appropriate to avoid full component tree rendering.
Mock child components as needed for isolation.
  </action>
  <verify>
    - File exists at frontend/src/components/dynamic/__tests__/DynamicField.spec.js
    - `grep -c "describe" frontend/src/components/dynamic/__tests__/DynamicField.spec.js` returns at least 4
    - `grep -c "it(" frontend/src/components/dynamic/__tests__/DynamicField.spec.js` returns at least 10
    - `grep -c "vi.mock" frontend/src/components/dynamic/__tests__/DynamicField.spec.js` returns at least 2 (useLogger + componentRegistry)
    - `cd /home/bernt-popp/development/gene-curator/frontend && npm run test:unit -- --run DynamicField.spec.js` passes
  </verify>
  <done>DynamicField.spec.js exists with 10+ test cases covering depth, registry, unknown types, and nested styling, with proper mocking for useLogger and componentRegistry</done>
</task>

<task type="auto">
  <name>Task 3: Run Full Test Suite and Verify</name>
  <files></files>
  <action>
Run the complete frontend test suite to ensure:

1. All new tests pass
2. No existing tests are broken
3. Test coverage is adequate

Commands to run:
```bash
cd frontend
npm run test:unit -- --run
```

If any tests fail:
- Fix the test or the implementation as needed
- Re-run until all pass

Also run lint to ensure test files follow project conventions:
```bash
cd frontend
npm run lint
```
  </action>
  <verify>
    - `cd /home/bernt-popp/development/gene-curator/frontend && npm run test:unit -- --run` passes with 0 failures
    - `cd /home/bernt-popp/development/gene-curator/frontend && npm run lint -- --max-warnings 0` passes
  </verify>
  <done>All frontend tests pass including new componentRegistry and DynamicField tests</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Test Files Exist:**
   - frontend/src/components/dynamic/__tests__/componentRegistry.spec.js
   - frontend/src/components/dynamic/__tests__/DynamicField.spec.js

2. **Test Coverage:**
   - Registry: exports, component lookup, null handling, case sensitivity
   - DynamicField: depth tracking, custom components, unknown types, nested styling
   - Proper mocking: useLogger mocked with vi.fn(), componentRegistry mocked with stub components

3. **All Tests Pass:**
   - `npm run test:unit -- --run` shows 0 failures
   - Lint passes with no warnings
</verification>

<success_criteria>
- componentRegistry.spec.js has 5+ test cases
- DynamicField.spec.js has 10+ test cases covering new functionality
- useLogger is properly mocked with vi.mock('@/composables/useLogger', ...)
- componentRegistry is properly mocked for test isolation
- All tests pass when run
- No lint warnings in test files
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-field-rendering/01-02-SUMMARY.md`
</output>
