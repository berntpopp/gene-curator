---
phase: 04-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/dynamic/DynamicField.vue
  - frontend/src/components/dynamic/composables/useValidationRules.js
  - frontend/src/components/dynamic/__tests__/useValidationRules.spec.js
autonomous: true

must_haves:
  truths:
    - "Required fields show 'Required' error when empty"
    - "Fields enforce minLength with error message showing character count"
    - "Fields enforce maxLength with error message showing character limit"
    - "Number fields enforce minimum value constraint"
    - "Number fields enforce maximum value constraint"
    - "Fields with pattern property validate input format"
    - "Fields with enum property reject values not in allowed list"
    - "Schema-defined errorMessage used when present, else default message"
  artifacts:
    - path: "frontend/src/components/dynamic/composables/useValidationRules.js"
      provides: "Validation rule generator composable"
      exports: ["useValidationRules"]
      min_lines: 80
    - path: "frontend/src/components/dynamic/__tests__/useValidationRules.spec.js"
      provides: "Test coverage for validation rules"
      min_lines: 100
  key_links:
    - from: "frontend/src/components/dynamic/DynamicField.vue"
      to: "useValidationRules"
      via: "computed property using composable"
      pattern: "useValidationRules.*fieldSchema"
---

<objective>
Complete client-side validation rule generation from JSON schema constraints.

Purpose: Enable DynamicField to enforce all schema validation constraints (required, minLength, maxLength, minimum, maximum, pattern, enum) using Vuetify's native :rules prop. This is the foundation for form-level validation control in Plan 02.

Output:
- useValidationRules composable with all rule generators
- DynamicField using composable for validation rules
- Test coverage for all validation rule types
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-validation/04-CONTEXT.md
@.planning/phases/04-validation/04-RESEARCH.md

Source files:
@frontend/src/components/dynamic/DynamicField.vue
@frontend/src/components/dynamic/__tests__/DynamicField.spec.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useValidationRules composable</name>
  <files>frontend/src/components/dynamic/composables/useValidationRules.js</files>
  <action>
Create a Vue composable that generates Vuetify validation rules array from field schema.

**Structure:**
```javascript
import { computed } from 'vue'

export function useValidationRules(fieldSchema, getFieldLabel) {
  const validationRules = computed(() => {
    // Generate rules array from schema constraints
  })
  return { validationRules }
}
```

**Rule generators (in order of application):**

1. **Required rule** (VALD-01):
   - Check `fieldSchema.required === true`
   - Message: schema.errorMessage OR 'Required'
   - Empty check: `value === null || value === undefined || value === ''`
   - For arrays: `!Array.isArray(value) || value.length === 0`

2. **minLength rule** (VALD-01):
   - Check `fieldSchema.minLength` exists
   - Skip validation if value is empty (falsy) - required handles empty
   - Message: schema.errorMessage OR `Minimum ${n} characters`

3. **maxLength rule** (VALD-01):
   - Check `fieldSchema.maxLength` exists
   - Skip validation if value is empty
   - Message: schema.errorMessage OR `Maximum ${n} characters`

4. **minimum rule** (VALD-01):
   - Check `fieldSchema.minimum !== undefined`
   - Skip validation if value is null/empty string
   - Message: schema.errorMessage OR `Minimum value: ${n}`

5. **maximum rule** (VALD-01):
   - Check `fieldSchema.maximum !== undefined`
   - Skip validation if value is null/empty string
   - Message: schema.errorMessage OR `Maximum value: ${n}`

6. **pattern rule** (VALD-02):
   - Check `fieldSchema.pattern` exists
   - Create RegExp from pattern string
   - Skip validation if value is empty
   - Message: schema.errorMessage OR 'Invalid format'

7. **enum rule** (VALD-03):
   - Check `fieldSchema.enum` exists and is array
   - Skip validation if value is empty
   - Check `fieldSchema.enum.includes(value)`
   - Message: schema.errorMessage OR 'Must be one of the allowed values'

**Decision from CONTEXT.md:** Show first error only - Vuetify handles this natively by showing first failing rule.

**Export:** `useValidationRules(fieldSchema, getFieldLabel)` returning `{ validationRules }`
  </action>
  <verify>File exists at frontend/src/components/dynamic/composables/useValidationRules.js with exported function</verify>
  <done>Composable exports useValidationRules function with all 7 rule generators</done>
</task>

<task type="auto">
  <name>Task 2: Integrate composable into DynamicField</name>
  <files>frontend/src/components/dynamic/DynamicField.vue</files>
  <action>
Refactor DynamicField to use the new useValidationRules composable.

**Changes:**

1. **Import composable:**
   ```javascript
   import { useValidationRules } from './composables/useValidationRules'
   ```

2. **Replace getValidationRules function** (lines 690-738):
   - Remove the existing `getValidationRules()` function
   - Call composable in setup: `const { validationRules } = useValidationRules(() => props.fieldSchema, getFieldLabel)`
   - Pass reactive getter for fieldSchema to maintain reactivity

3. **Update template bindings:**
   - Change `:rules="getValidationRules()"` to `:rules="validationRules"` on all Vuetify input components:
     - v-text-field (lines 22, 83, 146, 207, 308)
     - v-textarea (line 83)
     - v-select (line 146)
     - v-checkbox (line 282)

**Reactivity note:** The composable uses computed(), so rules automatically regenerate when fieldSchema prop changes. This addresses RESEARCH.md pitfall about non-reactive rules.

**Preserve:** Keep getErrorMessages() function unchanged - backend error integration is Plan 02.
  </action>
  <verify>npm run lint passes with no new errors</verify>
  <done>DynamicField uses useValidationRules composable, all input components bind :rules="validationRules"</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive test coverage</name>
  <files>frontend/src/components/dynamic/__tests__/useValidationRules.spec.js</files>
  <action>
Create test file for useValidationRules composable covering all rule types.

**Test structure:**
```javascript
import { describe, it, expect } from 'vitest'
import { ref } from 'vue'
import { useValidationRules } from '../composables/useValidationRules'

describe('useValidationRules', () => {
  const mockGetFieldLabel = () => 'Test Field'

  // Helper to extract rules and test them
  const getRules = (schema) => {
    const schemaRef = ref(schema)
    const { validationRules } = useValidationRules(
      () => schemaRef.value,
      mockGetFieldLabel
    )
    return validationRules.value
  }

  describe('required rule', () => {
    it('returns error for null value when required', () => { /* ... */ })
    it('returns error for undefined value when required', () => { /* ... */ })
    it('returns error for empty string when required', () => { /* ... */ })
    it('returns error for empty array when required', () => { /* ... */ })
    it('passes for non-empty value when required', () => { /* ... */ })
    it('uses schema errorMessage when provided', () => { /* ... */ })
    it('skips rule when not required', () => { /* ... */ })
  })

  describe('minLength rule', () => {
    it('returns error for string shorter than minLength', () => { /* ... */ })
    it('passes for string equal to minLength', () => { /* ... */ })
    it('passes for string longer than minLength', () => { /* ... */ })
    it('skips validation for empty value', () => { /* ... */ })
    it('uses schema errorMessage when provided', () => { /* ... */ })
  })

  describe('maxLength rule', () => {
    it('returns error for string longer than maxLength', () => { /* ... */ })
    it('passes for string equal to maxLength', () => { /* ... */ })
    it('passes for string shorter than maxLength', () => { /* ... */ })
    it('skips validation for empty value', () => { /* ... */ })
  })

  describe('minimum rule', () => {
    it('returns error for number below minimum', () => { /* ... */ })
    it('passes for number equal to minimum', () => { /* ... */ })
    it('passes for number above minimum', () => { /* ... */ })
    it('skips validation for null value', () => { /* ... */ })
  })

  describe('maximum rule', () => {
    it('returns error for number above maximum', () => { /* ... */ })
    it('passes for number equal to maximum', () => { /* ... */ })
    it('passes for number below maximum', () => { /* ... */ })
  })

  describe('pattern rule', () => {
    it('returns error for value not matching pattern', () => { /* ... */ })
    it('passes for value matching pattern', () => { /* ... */ })
    it('skips validation for empty value', () => { /* ... */ })
    it('uses schema errorMessage when provided', () => { /* ... */ })
  })

  describe('enum rule', () => {
    it('returns error for value not in enum', () => { /* ... */ })
    it('passes for value in enum', () => { /* ... */ })
    it('skips validation for empty value', () => { /* ... */ })
  })

  describe('combined rules', () => {
    it('generates multiple rules for schema with multiple constraints', () => { /* ... */ })
    it('returns empty array for schema with no constraints', () => { /* ... */ })
  })

  describe('reactivity', () => {
    it('recomputes rules when schema changes', () => { /* ... */ })
  })
})
```

**Test patterns:**
- Each rule function returns `true` on pass or error message string on fail
- Test both passing and failing cases
- Test edge cases (empty values, boundary values)
- Test schema.errorMessage override
- Test reactivity by changing schemaRef.value

**Run:** `npm run test -- useValidationRules` to verify all tests pass
  </action>
  <verify>npm run test -- useValidationRules passes all tests</verify>
  <done>Test file covers all 7 rule types with passing tests</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Lint check:**
   ```bash
   cd frontend && npm run lint
   ```
   Expected: No new errors (pre-existing CurationDetailView warning acceptable)

2. **Test check:**
   ```bash
   cd frontend && npm run test -- useValidationRules
   ```
   Expected: All tests pass

3. **Build check:**
   ```bash
   cd frontend && npm run build
   ```
   Expected: Build succeeds

4. **Grep verification:**
   ```bash
   grep -r "useValidationRules" frontend/src/components/dynamic/
   ```
   Expected: Import in DynamicField.vue, export in composable
</verification>

<success_criteria>
- useValidationRules composable exists with all 7 rule generators
- DynamicField imports and uses the composable
- All Vuetify input components use :rules="validationRules"
- Test file has 20+ test cases covering all rule types
- Lint, tests, and build all pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation/04-01-SUMMARY.md`
</output>
