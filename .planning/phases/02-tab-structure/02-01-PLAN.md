---
phase: 02-tab-structure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/dynamic/TabContent.vue
  - frontend/src/components/dynamic/DynamicForm.vue
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Form renders with v-tabs matching ui_configuration.layout.tabs array"
    - "Each tab displays its sections with fields grouped correctly"
    - "Sections are collapsible using v-expansion-panels with schema-defined defaults"
    - "Forms without ui_configuration render as flat field list (backward compatible)"
    - "Tab switching preserves form state via KeepAlive"
  artifacts:
    - path: "frontend/src/components/dynamic/TabContent.vue"
      provides: "Section rendering with collapsible expansion panels"
      exports: ["TabContent (default)"]
    - path: "frontend/src/components/dynamic/DynamicForm.vue"
      provides: "Tab navigation with v-tabs/v-window and fallback to flat rendering"
      contains: ["v-tabs", "v-window", "hasTabs computed", "validTabs computed"]
  key_links:
    - from: "DynamicForm.vue"
      to: "TabContent.vue"
      via: "component import and rendering in v-window-item"
      pattern: "import TabContent"
    - from: "DynamicForm.vue"
      to: "jsonSchema.ui_configuration.layout.tabs"
      via: "computed property validTabs"
      pattern: "ui_configuration.*layout.*tabs"
    - from: "TabContent.vue"
      to: "DynamicField.vue"
      via: "rendering fields from section.fields array"
      pattern: "v-for.*section\\.fields"
---

<objective>
Create the core tab structure for DynamicForm with section rendering inside tabs.

Purpose: Enable forms to organize fields into navigable tabs based on schema ui_configuration, improving UX for complex multi-section forms like ClinGen SOP v11.

Output: TabContent.vue component for section rendering, DynamicForm.vue enhanced with v-tabs/v-window navigation and backward-compatible flat fallback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tab-structure/02-CONTEXT.md
@.planning/phases/02-tab-structure/02-RESEARCH.md
@.planning/phases/01-field-rendering/01-01-SUMMARY.md
@frontend/src/components/dynamic/DynamicForm.vue
@frontend/src/components/dynamic/DynamicField.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TabContent Component</name>
  <files>frontend/src/components/dynamic/TabContent.vue</files>
  <action>
Create a new TabContent.vue component that renders sections within a tab:

1. **Props:**
   - `tab: Object` (required) - Tab configuration with id, name, sections array
   - `schema: Object` (required) - Full JSON schema for field lookups
   - `formData: Object` (required) - Current form data
   - `validationResult: Object` (default: null) - Validation result for error display
   - `readonly: Boolean` (default: false) - Disable all fields

2. **Section rendering with v-expansion-panels:**
   - Use `v-expansion-panels` with `multiple` prop (allows multiple open)
   - Use `variant="accordion"` for connected panel styling
   - Initialize `openSections` ref from schema defaults:
     - Sections with `collapsed: true` start closed
     - Sections without `collapsed` or with `collapsed: false` start open
     - Use index-based values (not IDs)

3. **Each expansion panel:**
   - `v-expansion-panel-title` shows section.name with optional section.icon
   - `v-expansion-panel-text` contains:
     - Optional help_text as caption above fields
     - v-row with DynamicField for each field in section.fields array

4. **Field path resolution helpers:**
   - `getFieldName(fieldPath)` - Extract last segment from dot-notation path
   - `getFieldSchema(fieldPath)` - Navigate schema.properties using path segments, handling nested object/array types
   - `getFieldValue(fieldPath)` - Navigate formData using path segments
   - `getFieldValidation(fieldPath)` - Extract field-specific errors from validationResult

5. **Emit `update:field` event** with (fieldPath, value) when DynamicField updates

6. **KeepAlive lifecycle hooks:**
   - Import `onActivated`, `onDeactivated` from vue
   - Log tab activation/deactivation using useLogger (debug level)

7. **Column sizing:**
   - Use `cols="12"` by default
   - Use `:sm="section.fields.length > 2 ? 6 : 12"` for responsive 2-column layout when section has 3+ fields
  </action>
  <verify>
Run: `cd /home/bernt-popp/development/gene-curator/frontend && npm run lint -- --fix`
Confirm: No lint errors in TabContent.vue
  </verify>
  <done>TabContent.vue exists with v-expansion-panels rendering sections, field path helpers, and KeepAlive lifecycle hooks</done>
</task>

<task type="auto">
  <name>Task 2: Enhance DynamicForm with Tabs</name>
  <files>frontend/src/components/dynamic/DynamicForm.vue</files>
  <action>
Enhance the existing DynamicForm.vue to support tabbed layout while preserving flat fallback:

1. **Import TabContent component:**
   ```javascript
   import TabContent from './TabContent.vue'
   ```

2. **Add tab-related reactive state:**
   - `activeTab = ref(null)` - Currently selected tab ID

3. **Add computed properties for tab validation:**
   - `hasTabs` - Returns true if:
     - `jsonSchema.value?.ui_configuration?.layout?.type === 'tabs'`
     - `jsonSchema.value?.ui_configuration?.layout?.tabs` is non-empty array
     - Log debug message when using flat rendering (no layout or wrong type)
     - Log warning when tabs array invalid
   - `validTabs` - Filters `ui_configuration.layout.tabs` to include only tabs with:
     - Valid `id` and `name` properties
     - Non-empty `sections` array
     - Log warning for each invalid tab skipped
     - If fewer than 2 valid tabs remain after filtering, return empty array (triggers flat fallback)

4. **Initialize activeTab on validTabs change:**
   - Watch `validTabs` with `{ immediate: true }`
   - Set `activeTab.value = tabs[0].id` when tabs available and activeTab not set

5. **Template structure (conditional rendering):**
   ```vue
   <!-- Loading state (existing) -->
   <div v-if="loading">...</div>

   <!-- Tabbed Layout (NEW) -->
   <div v-else-if="hasTabs">
     <v-tabs v-model="activeTab" show-arrows color="primary" density="comfortable">
       <v-tab v-for="tab in validTabs" :key="tab.id" :value="tab.id">
         <v-icon v-if="tab.icon" :icon="tab.icon" start />
         {{ tab.name }}
       </v-tab>
     </v-tabs>

     <v-window v-model="activeTab">
       <v-window-item v-for="tab in validTabs" :key="tab.id" :value="tab.id">
         <KeepAlive>
           <TabContent
             :tab="tab"
             :schema="jsonSchema"
             :form-data="formData"
             :validation-result="validationResult"
             :readonly="readonly"
             @update:field="handleTabFieldUpdate"
           />
         </KeepAlive>
       </v-window-item>
     </v-window>
   </div>

   <!-- Flat Fallback (existing, wrapped in else-if) -->
   <div v-else-if="jsonSchema && jsonSchema.properties">...</div>

   <!-- Error state (existing) -->
   <v-alert v-else-if="error">...</v-alert>
   ```

6. **Add handleTabFieldUpdate method:**
   - Receives `(fieldPath, value)` from TabContent
   - Handles nested paths using dot notation
   - For nested paths (contains '.'), use setNestedValue helper
   - For flat paths, directly update `formData.value[fieldPath] = value`
   - Emit `update:modelValue` with updated formData

7. **Add setNestedValue helper function:**
   ```javascript
   function setNestedValue(obj, path, value) {
     const keys = path.split('.')
     const lastKey = keys.pop()
     const target = keys.reduce((acc, key) => {
       if (!acc[key]) acc[key] = {}
       return acc[key]
     }, obj)
     target[lastKey] = value
   }
   ```

8. **Move validation/score summary OUTSIDE the conditional blocks:**
   - The existing v-alert for validation errors and the score_calculations section should render after the form content (tab or flat) but still inside v-card-text
   - This ensures validation feedback appears regardless of layout type

9. **Preserve existing functionality:**
   - Keep all existing props, emits, watchers
   - Keep existing updateField for flat layout (it handles non-nested paths)
   - Keep validateForm, validateField, handleSubmit, saveDraft
  </action>
  <verify>
Run: `cd /home/bernt-popp/development/gene-curator/frontend && npm run lint -- --fix && npm run build`
Confirm: No lint errors, build succeeds
  </verify>
  <done>DynamicForm.vue renders v-tabs when ui_configuration.layout.tabs exists, falls back to flat rendering otherwise, KeepAlive preserves tab state</done>
</task>

</tasks>

<verification>
1. **Lint passes:** `cd frontend && npm run lint` shows no errors
2. **Build succeeds:** `cd frontend && npm run build` completes without errors
3. **Type structure:** grep for `hasTabs`, `validTabs`, `TabContent` in DynamicForm.vue
4. **KeepAlive present:** grep for `KeepAlive` in DynamicForm.vue template
</verification>

<success_criteria>
- TabContent.vue renders sections with collapsible v-expansion-panels
- DynamicForm.vue shows v-tabs when valid ui_configuration.layout.tabs exists
- DynamicForm.vue falls back to flat rendering when ui_configuration absent or invalid
- Tab switching preserves component state via KeepAlive
- All fields within sections render via DynamicField with proper path resolution
- Lint and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-tab-structure/02-01-SUMMARY.md`
</output>
