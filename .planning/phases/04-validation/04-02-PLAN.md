---
phase: 04-validation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - frontend/src/components/dynamic/DynamicForm.vue
  - frontend/src/components/dynamic/DynamicField.vue
  - frontend/src/components/dynamic/TabContent.vue
  - frontend/src/components/dynamic/__tests__/DynamicForm.validation.spec.js
autonomous: true

must_haves:
  truths:
    - "Backend validation errors appear inline on affected fields"
    - "Backend errors clear when user modifies the field"
    - "Non-field backend errors display as alert at top of form"
    - "Tabs with validation errors show red dot badge"
    - "Form submit button is disabled when validation fails"
    - "Submit attempt navigates to first tab with error"
    - "First invalid field receives focus on submit attempt"
  artifacts:
    - path: "frontend/src/components/dynamic/DynamicForm.vue"
      provides: "Form validation orchestration"
      contains: "backendErrors"
      min_lines: 500
    - path: "frontend/src/components/dynamic/__tests__/DynamicForm.validation.spec.js"
      provides: "Validation integration tests"
      min_lines: 80
  key_links:
    - from: "frontend/src/components/dynamic/DynamicForm.vue"
      to: "frontend/src/components/dynamic/DynamicField.vue"
      via: "backend-errors prop"
      pattern: ":backend-errors="
    - from: "frontend/src/components/dynamic/DynamicForm.vue"
      to: "formRef.validate()"
      via: "handleSubmit method"
      pattern: "formRef.*validate"
---

<objective>
Wire backend validation errors to fields and implement form submission blocking.

Purpose: Complete the validation integration by mapping backend errors to individual fields, showing tab error badges, and blocking form submission until validation passes. This fulfills VALD-04, VALD-05, VALD-06 requirements.

Output:
- Backend errors displayed inline on affected fields
- Tab headers show error dot when containing invalid fields
- Form submission blocked with v-form.validate()
- Test coverage for validation integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-validation/04-CONTEXT.md
@.planning/phases/04-validation/04-RESEARCH.md
@.planning/phases/04-validation/04-01-SUMMARY.md

Source files:
@frontend/src/components/dynamic/DynamicForm.vue
@frontend/src/components/dynamic/DynamicField.vue
@frontend/src/components/dynamic/TabContent.vue
@frontend/src/stores/validation.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend error state and mapping in DynamicForm</name>
  <files>frontend/src/components/dynamic/DynamicForm.vue</files>
  <action>
Add backend error state management to DynamicForm.

**1. Add state for backend errors:**
```javascript
// In script setup, after formRef
const backendErrors = ref({})       // { fieldPath: [error messages] }
const nonFieldErrors = ref([])      // Errors not mapped to specific fields
```

**2. Create backend error handler:**
```javascript
/**
 * Process backend validation result and map errors to fields
 * @param {Object} result - Validation result from backend
 */
const handleBackendValidation = (result) => {
  backendErrors.value = {}
  nonFieldErrors.value = []

  if (!result || result.is_valid) return

  // Map field-specific errors
  if (result.field_validations) {
    Object.entries(result.field_validations).forEach(([field, validation]) => {
      if (validation.errors && validation.errors.length > 0) {
        // Take first error only per CONTEXT.md decision
        backendErrors.value[field] = [validation.errors[0].message]
      }
    })
  }

  // Collect non-field errors (errors without field mapping)
  if (result.errors) {
    result.errors.forEach(error => {
      if (!error.field || !result.field_validations?.[error.field]) {
        nonFieldErrors.value.push(error.message)
      }
    })
  }
}
```

**3. Clear backend error on field change:**
```javascript
/**
 * Clear backend error for a specific field
 * @param {string} fieldPath - Field path (supports dot notation)
 */
const clearFieldBackendError = (fieldPath) => {
  if (backendErrors.value[fieldPath]) {
    delete backendErrors.value[fieldPath]
  }
}
```

**4. Update validateForm to use handler:**
```javascript
const validateForm = async () => {
  try {
    const result = await validationStore.validateEvidence(formData.value, props.schemaId, 'form')
    handleBackendValidation(result)
  } catch (error) {
    logger.error('Form validation error:', { error: error.message })
  }
}
```

**5. Add non-field error alert (after existing validation alert, around line 78):**
```html
<v-alert
  v-if="nonFieldErrors.length > 0"
  type="error"
  variant="tonal"
  class="mb-4"
  closable
  @click:close="nonFieldErrors = []"
>
  <template #prepend>
    <v-icon>mdi-alert-circle</v-icon>
  </template>
  <div class="font-weight-medium">Form Error</div>
  <div v-for="(msg, idx) in nonFieldErrors" :key="idx">{{ msg }}</div>
</v-alert>
```

**6. Update updateField to clear backend errors:**
In both `updateField` and `handleTabFieldUpdate`, call `clearFieldBackendError(fieldName)` before updating formData.

**7. Add computed for tab error state:**
```javascript
/**
 * Track which tabs have validation errors
 */
const tabValidationErrors = computed(() => {
  const errors = {}

  validTabs.value.forEach(tab => {
    // Get all field paths in this tab
    const fieldsInTab = getTabFieldPaths(tab)
    const hasErrors = fieldsInTab.some(fieldPath =>
      backendErrors.value[fieldPath]?.length > 0
    )
    errors[tab.id] = hasErrors
  })

  return errors
})

/**
 * Extract all field paths from a tab's sections
 */
const getTabFieldPaths = (tab) => {
  const paths = []
  tab.sections?.forEach(section => {
    section.fields?.forEach(fieldPath => {
      paths.push(fieldPath)
    })
  })
  return paths
}
```
  </action>
  <verify>npm run lint passes with no new errors</verify>
  <done>Backend error state, handler, clearing, and tab error tracking implemented in DynamicForm</done>
</task>

<task type="auto">
  <name>Task 2: Add backend-errors prop to DynamicField and wire through components</name>
  <files>
    frontend/src/components/dynamic/DynamicField.vue
    frontend/src/components/dynamic/TabContent.vue
    frontend/src/components/dynamic/DynamicForm.vue
  </files>
  <action>
Wire backend errors through component hierarchy to display inline on fields.

**DynamicField.vue changes:**

1. **Add backendErrors prop:**
```javascript
const props = defineProps({
  // ... existing props
  backendErrors: {
    type: Array,
    default: () => []
  }
})
```

2. **Update getErrorMessages to merge backend errors:**
```javascript
const getErrorMessages = () => {
  // Backend errors passed via prop (from DynamicForm)
  if (props.backendErrors && props.backendErrors.length > 0) {
    return props.backendErrors
  }

  // Fallback to validationResult (existing pattern)
  if (props.validationResult?.errors) {
    return props.validationResult.errors.map(error => error.message)
  }
  return []
}
```

**Note:** Per CONTEXT.md decision, client errors (from :rules) take priority. Vuetify shows rules errors first, error-messages only if rules pass. We pass backend errors via error-messages prop.

3. **Add emit for backend error clear:**
```javascript
const emit = defineEmits(['update:model-value', 'validate', 'component-fallback', 'clear-backend-error'])

const updateValue = value => {
  emit('update:model-value', value)
  emit('clear-backend-error')  // Signal to parent to clear backend error
}
```

**TabContent.vue changes:**

1. **Accept backendErrors prop:**
```javascript
const props = defineProps({
  // ... existing props
  backendErrors: {
    type: Object,
    default: () => ({})
  }
})
```

2. **Add emit for clear:**
```javascript
const emit = defineEmits(['update:field', 'clear-backend-error'])
```

3. **Pass to DynamicField:**
Update DynamicField usage in template:
```html
<DynamicField
  :field-name="getFieldName(fieldPath)"
  :field-schema="getFieldSchema(fieldPath)"
  :model-value="getFieldValue(fieldPath)"
  :validation-result="getFieldValidation(fieldPath)"
  :backend-errors="backendErrors[fieldPath] || []"
  :disabled="readonly"
  @update:model-value="$emit('update:field', fieldPath, $event)"
  @clear-backend-error="$emit('clear-backend-error', fieldPath)"
/>
```

**DynamicForm.vue changes:**

1. **Pass backendErrors to TabContent:**
```html
<TabContent
  :tab="tab"
  :schema="jsonSchema"
  :form-data="formData"
  :validation-result="validationResult"
  :backend-errors="backendErrors"
  :readonly="readonly"
  @update:field="handleTabFieldUpdate"
  @clear-backend-error="clearFieldBackendError"
/>
```

2. **Pass backendErrors to flat layout DynamicField:**
```html
<DynamicField
  :field-name="fieldName"
  :field-schema="field"
  :model-value="formData[fieldName]"
  :validation-result="getFieldValidation(fieldName)"
  :backend-errors="backendErrors[fieldName] || []"
  :disabled="readonly"
  @update:model-value="updateField(fieldName, $event)"
  @validate="validateField(fieldName, $event)"
  @clear-backend-error="clearFieldBackendError(fieldName)"
/>
```
  </action>
  <verify>npm run lint passes with no new errors</verify>
  <done>Backend errors prop wired through DynamicForm -> TabContent -> DynamicField with clear event bubbling</done>
</task>

<task type="auto">
  <name>Task 3: Add tab error badges and form submission blocking</name>
  <files>frontend/src/components/dynamic/DynamicForm.vue</files>
  <action>
Implement tab error badges and v-form validation on submit.

**1. Add error badge to tab headers:**
Update the v-tab in template (around line 18):
```html
<v-tab v-for="tab in validTabs" :key="tab.id" :value="tab.id">
  <v-icon v-if="tab.icon" :icon="tab.icon" start />
  {{ tab.name }}
  <v-chip
    v-if="tab.show_score_badge && tabScores[tab.id] !== undefined"
    :color="getScoreColor(tabScores[tab.id])"
    size="small"
    variant="flat"
    class="ml-2"
  >
    {{ tabScores[tab.id] }}
  </v-chip>
  <!-- Error badge -->
  <v-badge
    v-if="tabValidationErrors[tab.id]"
    color="error"
    dot
    inline
    class="ml-2"
  />
</v-tab>
```

**2. Update handleSubmit to use v-form validation:**
```javascript
const handleSubmit = async () => {
  submitting.value = true
  try {
    // Validate using v-form ref (VALD-06)
    const { valid } = await formRef.value.validate()

    if (!valid) {
      // Find first tab with error and navigate to it
      const firstErrorTab = findFirstInvalidTab()
      if (firstErrorTab) {
        activeTab.value = firstErrorTab
        // Focus first invalid field after tab switch
        await nextTick()
        focusFirstInvalidField()
      }
      return
    }

    // Also check backend validation
    await validateForm()

    if (validationResult.value?.is_valid !== false) {
      emit('submit', formData.value)
    }
  } catch (error) {
    logger.error('Submit error:', { error: error.message })
  } finally {
    submitting.value = false
  }
}
```

**3. Add helper functions:**
```javascript
import { nextTick } from 'vue'

/**
 * Find first tab containing validation errors
 */
const findFirstInvalidTab = () => {
  for (const tab of validTabs.value) {
    if (tabValidationErrors.value[tab.id]) {
      return tab.id
    }
  }
  return null
}

/**
 * Focus first field with validation error in current tab
 */
const focusFirstInvalidField = () => {
  // Query for Vuetify input with error state
  const errorInput = document.querySelector('.v-input--error input, .v-input--error textarea')
  if (errorInput) {
    errorInput.focus()
    logger.debug('Focused first invalid field')
  }
}
```

**4. Update canSubmit computed:**
```javascript
const canSubmit = computed(() => {
  // Block if backend validation failed
  if (validationResult.value?.is_valid === false) return false
  // Block if any backend errors present
  if (Object.keys(backendErrors.value).length > 0) return false
  // Block if no changes
  if (!hasChanges.value) return false
  return true
})
```

**5. Update submit button to show validation state:**
```html
<v-btn
  type="submit"
  color="primary"
  variant="flat"
  :loading="submitting"
  :disabled="!canSubmit"
>
  <v-icon start>mdi-check</v-icon>
  Submit
</v-btn>
```
  </action>
  <verify>npm run lint passes with no new errors</verify>
  <done>Tab error badges display, submit uses v-form.validate(), navigates to first error tab, focuses first invalid field</done>
</task>

<task type="auto">
  <name>Task 4: Add validation integration tests</name>
  <files>frontend/src/components/dynamic/__tests__/DynamicForm.validation.spec.js</files>
  <action>
Create test file for DynamicForm validation integration.

**Test file structure:**
```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import DynamicForm from '../DynamicForm.vue'

// Mock validation store
vi.mock('@/stores', () => ({
  useValidationStore: () => ({
    loading: false,
    error: null,
    getJsonSchema: () => ({
      properties: {
        name: { type: 'string', required: true },
        email: { type: 'string', pattern: '^[^@]+@[^@]+$' }
      }
    }),
    getValidationResult: () => null,
    generateJsonSchema: vi.fn(),
    validateEvidence: vi.fn()
  })
}))

// Mock logger
vi.mock('@/composables/useLogger', () => ({
  useLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

// Vuetify component stubs
const vuetifyStubs = {
  'v-form': { template: '<form ref="formRef"><slot /></form>', methods: { validate: () => ({ valid: true }) } },
  'v-card': { template: '<div><slot /></div>' },
  'v-card-title': { template: '<div><slot /></div>' },
  'v-card-text': { template: '<div><slot /></div>' },
  'v-card-actions': { template: '<div><slot /></div>' },
  'v-btn': { template: '<button :disabled="$attrs.disabled"><slot /></button>' },
  'v-alert': { template: '<div v-if="$attrs.modelValue !== false"><slot /></div>' },
  'v-icon': { template: '<span />' },
  'v-spacer': { template: '<span />' },
  'v-progress-circular': { template: '<span />' },
  'v-tabs': { template: '<div><slot /></div>' },
  'v-tab': { template: '<div><slot /></div>' },
  'v-window': { template: '<div><slot /></div>' },
  'v-window-item': { template: '<div><slot /></div>' },
  'v-badge': { template: '<span class="v-badge" :class="{ dot: $attrs.dot }"><slot /></span>' },
  'v-chip': { template: '<span><slot /></span>' }
}

describe('DynamicForm Validation', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  describe('backend error display', () => {
    it('shows backend errors inline on affected fields', async () => {
      // Test backendErrors prop passed to DynamicField
    })

    it('clears backend error when field value changes', async () => {
      // Test clearFieldBackendError called on update
    })

    it('shows non-field errors in alert', async () => {
      // Test nonFieldErrors alert visibility
    })
  })

  describe('tab error badges', () => {
    it('shows error badge on tabs with invalid fields', async () => {
      // Test tabValidationErrors computed
    })

    it('hides error badge when field errors are cleared', async () => {
      // Test badge removal
    })
  })

  describe('form submission', () => {
    it('blocks submission when validation fails', async () => {
      // Test canSubmit computed
    })

    it('navigates to first error tab on submit attempt', async () => {
      // Test findFirstInvalidTab call
    })

    it('emits submit event when validation passes', async () => {
      // Test successful submission
    })
  })
})
```

**Note:** Use existing DynamicField.spec.js stub patterns from [03-02] decision for Vuetify components.

**Run:** `npm run test -- DynamicForm.validation` to verify tests pass
  </action>
  <verify>npm run test -- DynamicForm.validation passes all tests</verify>
  <done>Test file covers backend error display, tab badges, and form submission blocking</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Lint check:**
   ```bash
   cd frontend && npm run lint
   ```
   Expected: No new errors

2. **Test check:**
   ```bash
   cd frontend && npm run test -- DynamicForm.validation
   ```
   Expected: All tests pass

3. **Build check:**
   ```bash
   cd frontend && npm run build
   ```
   Expected: Build succeeds

4. **Grep verification:**
   ```bash
   grep -r "backendErrors" frontend/src/components/dynamic/
   grep -r "tabValidationErrors" frontend/src/components/dynamic/
   grep -r "formRef.*validate" frontend/src/components/dynamic/
   ```
   Expected: All patterns found in DynamicForm.vue
</verification>

<success_criteria>
- Backend errors mapped to fields via backendErrors state
- DynamicField accepts backendErrors prop and displays via error-messages
- Backend errors clear on field change
- Non-field errors display in alert
- Tab headers show red dot badge when containing errors
- Form submission blocked until validation passes
- Submit navigates to first error tab and focuses field
- Test coverage for validation integration
- All lint, tests, and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation/04-02-SUMMARY.md`
</output>
